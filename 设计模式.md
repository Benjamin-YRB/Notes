# 设计模式与软件体系架构

### 三个层次

- 架构模式
  - 高层模式，用于描述系统级别的结构组成、相互关系以及相关约束。对架构模式的选择是最基本的设计决策。
  - 例如：MVC模式就是一种架构模式：给出了一种交互式系统的架构设计，主要思想是实现业务逻辑、用户界面的分离。
- 设计模式
  - 中层模式，是针对系统局部设计问题给出的解决方案，一般设计模式都是指中层设计模式，在实现架构模式时，可能使用多种设计模式。
  - 例如：在实现MVC架构模式设计时，采用的主要设计有观察者模式、组合模式和策略模式等。
- 习惯用法
  - 架构模式和设计模式一般与具体语言无关，而习惯用法则与具体的语言机制有关。

### 软件设计模式的分类

| 面向对象   | 分布式计算     | 企业应用软件            | 面向服务的体系结构（SOA） |
| ---------- | -------------- | ----------------------- | ------------------------- |
| 创建型模式 | 从混沌到结构   | 领域逻辑模式            | 服务设计模式              |
| 结构型模式 | 分布式基础设施 | 数据源架构模式          | 服务库设计模式            |
| 行为型模式 | 事件分离与分发 | 对象-关系行为模式       | 服务组合设计模式          |
|            | 接口划分       | 对象-关系结构模式       |                           |
|            | 组件划分       | 对象-关系元数据映射模式 |                           |
|            | 应用控制       | Web表示模式             |                           |
|            | 并发           | 分布模式                |                           |
|            | 同步           | 离线并发模式            |                           |
|            | 对象交互       | 会话状态模式            |                           |
|            | 适配与扩展     | 基本模式                |                           |
|            | 模态行为       |                         |                           |
|            | 资源管理       |                         |                           |
|            | 数据库访问     |                         |                           |

### 面向对象设计模式

- 创建型模式（5种）

  有工厂方法模式、抽象工厂方法模式、生成器模式、单例模式和建造者模式

- 结构型模式（7种）

  有组合模式、适配器模式、外观模式、桥接模式、代理模式、装饰模式、外观模式、享元模式

- 行为型模式（11种）

  模版方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式、迭代器模式、访问者模式、备忘录模式、解释器模式。

### 设计模式的目的

1. 代码重用性
   - 相同功能的代码，不用重复编写
2. 可读性
   - 编程规范性
3. 可扩展性
   - 
4. 可靠性
5. 使程序呈现高内聚、低耦合

### 七大原则

- 单一职责原则

  1. 降低类的复杂度，一个类只负责一项职责。
  2. 提高类的可读性，可维护性
  3. 降低变更引起的风险
  4. 通常情况下，应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则，只有类中方法数量足够少，可以在方法级别保持单一职责原则。

- 接口隔离原则

  1. 客户端不应该依赖它不需要的接口（即，暴露给客户端的接口一定是它能用的，而不是告诉它它不能用），一个类对另一个类的依赖应该建立在最小的接口上。

- 依赖倒转（倒置）原则

  1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象。
  2. **抽象不应该依赖细节，细节应该依赖抽象**。
  3.   依赖倒转的中心思想是**面向接口编程**。
  4. 相对于细节的多变性，抽象的东西要稳定的多，以抽象为基础搭建的框架比以细节的框架稳定的多，在java中，抽象指的是接口或者抽象类，细节就是具体的实现类。
  5. 使用接口或抽象类的目的是制定规范，而不设计任何具体的操作，具体的操作由实现类来完成。 

  > 1. 低层模块尽量都要有抽象类或接口（即子类继承的父类尽量是抽象类或实现接口），或者两个都有，程序稳定性更好。
  > 2. 变量的生命类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化。
  > 3. 继承时遵循里氏替换原则

  > 依赖关系传递的三种方式
  >
  > 1. 接口传递
  > 2. 构造方法传递
  > 3. setter传递

- 里氏替换原则

  - 定义
    - 通俗的讲：子类可以扩展父类的功能，但不能改变父类原有的功能。
    - 满足里氏替换原则的程序中，将一个基类对象替换为子类对象，程序将不会产生任何错误和异常，反过来则不一定成立。
    - 里氏替换原则是实现开闭原则的重要方式之一，由于使用基类的地方都可以使用子类，因此在程序中尽量使用基类来对对象进行定义，而在运行时再确定其子类型，用子类对象来替换父类对象。
  - 包含的含义：
    - 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法
    - 子类可以增加自己特有的方法
  - **若子类要重写父类中已经实现的方法时，通用的解决方案是创建一个更加基础的类，让父类和子类都继承这个类，将原有的继承关系去掉，采用依赖、聚合、组合等关系替代**

- 开闭原则

- 迪米特法则

- 合成复用原则



## 理解依赖、关联、聚合、组合

- 依赖（Dependency）：表示一个类依赖于另一个类的定义。一般而言，依赖关系在java中体现为一个类是另一个类的局部变量、方法的形参、或对静态方法的调用。

- 关联（Association）：使一个类知道另一个类的属性和方法，关联可以是双向的，也可以是单向的，在java中，关联一般使用成员变量来实现。
- 聚合（Aggregation）：强关联关系，是关联关系的一种，表示的是整体和个体之间的关系，例如，汽车类和轮胎、引擎类之间的关系便是整体和个体，聚合关系也是通过实例变量来实现的，但是关联关系所涉及的两个类是处在同一层次的，聚合关系中两个类是处于不平等层次上的，一个整体，一个部分。
- 组合（Compostion）：也是关联关系的一种，关联性比聚合还要强。要求普通的聚合关系中代表整体的对象（下称整体对象）负责保持代表部分的对象（下称部分对象）的生命周期，组合关系是不能共享的。整体对象需要负责保持部分对象的存活，在一些情况下将部分对象湮灭掉。整体对象可以将部分对象传递给另一个对象，由后者负责此对象的生命周期。换言之，部分对象任意时刻只能和一个对象发生组合关系，后者排他的负责生命周期。部分和整体的生命周期一样。

```java
package relationship;

public class Driver {
    //使用局部变量发生依赖关系
    public void drive2(){
        Car car = new Car();
        car.run();
    }
    //使用静态变量发生依赖关系
    public void drive3(){
        Car.run();
    }
    //形参发生依赖关系：表示我得有车才能开车；也可以是关联关系，表示别人给我什么车，我就开什么车
    public void drive(Car car){
        car.run();
    }


    //使用成员变量形式实现关联，车是我的，我可以使用这个车；语义不同时也可以表示聚合，车是私家车
    private Car myCar;
    public void drive4(){
        myCar.run();
    }

    //想要达到组合关系，一般使用构造方法来达到初始化管理生命周期
    public Driver(Car car){
        myCar = car;
    }
}

class Car{
    public static void run(){
        System.out.println("汽车在奔跑");
    }
}
```

> 因此，关联、聚合、组合只能配合语义，结合上下文才能够判断，只看代码无法判断。

