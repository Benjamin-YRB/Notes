# Java面试宝典

### 1、一个”.java“源文件是否可以包含多个类（非内部类）？有什么限制？

​	可以包含多个类，但只能有一个public class，并且public修饰的类名和.java文件名一致。

### 2、&和&&的区别

1. &和&&都可以做逻辑“与”运算的运算符，当两边的条件都为true时整个运算的结果才是true，否则都为false。
2. &&还具有短路的功能，若第一个表达式为false，则不再运算第二个表达式，如：if(str!=null&&str.equals(""))表达式，若str为null，后面的表达式不再运行，不会抛出NPE，若将&&改为&，则会抛出NPE。
3. &还可以做位运算符，当操作符两边都不是boolean类型时，&表示按位与操作。

### 3、在java中如何跳出多重循环？

​	可在外重循环前定义一个标号，在内层循环的代码中使用带有标号的break语句即可跳出标定的循环。

![image-20201112220032922](/Users/yangxiansheng/笔记/images/image-20201112220032922.png)

### 4、switch语句能否作用在byte上？能否作用在long上？能否作用在String上？

- JDK1.0-JDK1.4	只能接受byte、short、int、char，因为上述列举基本类型都能够自动向上转型成int。
- JDK1.5  接受byte、short、int、char、enum（枚举类型）
- JDK1.7  接受byte、short、int、char、enum、String六种类型

### 5、short s1 = 1; s1 = s1 + 1;有什么错？short s1 = 1;s1+=1;有什么错？

​	前者：s1+1运算之后，s1自动向上转型成为int类型，然后有赋值给short类型，因此编译器会报类型转换错误（不能自动向下转型），后者由于+=是java语言规定的运算符，java编译器会进行特殊处理，因此可以正确编译，并且s1+=1运算之后，仍然可以用short类型来接收s1（即s1还是short类型）。

### 6、java中数据类型在内存中的存储原理

1. 基本数据类型的存储原理：所有的简单数据类型不存在”引用“的概念，数据本身的值就是存储在栈中，java中的八种基本类型（byte、short、int、long、float、double、boolean、char）都是这种存储模型。
2. 引用类型的存储原理：引用类型继承于Object类（也是引用类型），也是按照java中存储对象的内存模型进行存储（堆和栈）。

> “引用”类似指针，“引用”在栈中，存储着指向堆中对象的地址，而整个对象存储在堆中，可以通过引用中的地址找到堆中的对象

### 7、char型变量能不能存储一个中文汉字？为什么？

​	可以，char型变量是用来存储Unicode编码的字符的，因为Unicode编码占用两个字节，因此char类型的长度是两个字节16位，Unicode编码中包含常用汉字，可以存储汉字，但若是特殊的汉字（没有被Unicode编码包含的汉字）则char无法存储该汉字。

### 8、用最有效率的方法计算2的3次方

```java
2<<3
```

​	使用CPU直接支持的位运算效率最高，一个数左移n位，相当于乘了2的n次方。

### 9、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

​	使用final修饰变量时，是引用不能变，即这个引用只能指向这个对象，即栈中引用的地址值不能变，但是堆中的这个对象还是可以被其他引用改变的。

```java
final StringBuilder a = new StringBuilder("Hello");

a = new StringBuilder();//编译错误，a不可指向别的对象

a.append(" World");//可以编译
```

### 10、静态变量和实例变量的区别？

​	**实例变量**属于某个对象的域（属性），必须创建对象，该对象的实例变量才会被分配空间，才能使用该实例变量，静态变量不属于某个对象，而是直接属于类，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间进而使用。

> 何时JVM才加载类的字节码？
>
> ​	JVM规定：一个类或者接口在初次使用时，必须进行初始化。
>
> 主动使用的几种情况：
>
> - 创建一个类的实例，如new 关键字创建该类对象、反射、拷贝、反序列化等
> - 调用类的静态方法
> - 当初始化子类时，必须先初始化父类
> - 作为启动虚拟机，含有main方法的那个类

​	总而言之，实例变量必须创建对象之后才能通过这个对象来使用，而静态变量可以直接通过类名来引用。

### 11、是否可以从一个static方法内部发出对非static方法的调用？

​	不可以，非static方法是成员方法，必须通过对象来调用，而static方法无需创建对象即可调用，即调用一个static方法时，可能还没创建任何对象，自然不可能调用非static方法。

### 12、Integer和int的区别

int是java八大**基础类型**之一，Integer是int的包装类（**引用类型**），int的默认值为0，Integer默认值为null，Integer可以区分出变量是否被赋值，int则不行。

### 13、请说出public、protect、private和不写的区别

| 权限修饰符      | 当前类 | 同一个包（package） | 子孙类 | 其他包 |
| --------------- | ------ | ------------------- | ------ | ------ |
| public          | o      | o                   | o      | o      |
| protect         | o      | o                   | o      | x      |
| default（不写） | o      | o                   | x      | x      |
| private         | o      | x                   | x      | x      |

### 14、Override和Overload的区别，Overload能否改变返回值类型？

​	Overload是重载，Override是覆盖重写。

​	Overload表示一个类中可以有多个名称相同的方法，但这些方法的参数列表不同（个数或者类型不同）

​	Override表示子类的方法可以与父类的某个方法的名称和参数完全相同，通过子类对象调用该方法时，将调用子类中的重写方法，相当于父类的那个方法被覆盖了。

> 子类覆盖父类方法时，只能比父类抛出更少的异常，或者是父类抛出异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题，子类的访问权限只能更大，不能更小，如果父类的访问权限时private，则子类不存在覆盖的限制，相当于增加了一个全新的方法。

不能通过单纯的改变返回值类型来达到重载的目的。

#### Override

​	覆盖一个方法并且重写，以求达到不同的效果，覆盖时要注意以下几点：

- 覆盖的方法的标志必须要和被覆盖的方法标志完全匹配，才能达到覆盖的效果。
- 覆盖的方法的返回值必须和被覆盖方法的返回值一致。
- 覆盖的方法所抛出的异常必须和被覆盖方法的异常一致，或者是其子类。
- 被覆盖的方法不能是private，否则在其子类只是定义了一个新方法，并没有对其进行覆盖。

#### Overload

指可以在一个类中定义相同名字的方法，通过定义不同的参数列表来区分这些方法，在调用时。JVM会根据不同的参数样式来调用合适的方法，重载的注意事项：

- 在使用重载时，只能通过不同的参数列表，如不同的参数类型、个数以及顺序等
- 不能通过访问权限、返回类型、抛出的异常进行重载
- 方法的异常类型和数目不会对重载造成影响

### 15、构造器Constructor是否可被重写？

​	构造器不能被重写，但可被重载（有参和无参构造方法）

### 16、接口是否可被继承？抽象类能否实现接口？抽象类能否继承具体类？抽象类中是否可以有静态的main方法？

​	接口可以继承接口，抽象类可以实现接口，抽象类可以继承具体类，抽象类中可以有静态的main方法。

#### 接口和抽象类的区别

概念不同：

- 抽象类：对类的抽象，对类的每个属性、方法进行抽象。
- 接口：对行为进行抽象，对类的行为（方法）部分进行了抽象，对动作的抽象。

- 抽象类和接口都不能直接实例化