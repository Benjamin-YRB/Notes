# java基础

## Java基本数据类型

- 变量就是申请内存来存储值，即在创建变量时，需要申请内存空间，内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来存储该类型数据。

- 通过定义不同类型的变量，可以在内存中存储整数、小数或字符。

- java的两大数据类型：
  - 内置数据类型
  - 引用数据类型

### 内置数据类型

​	java提供了八种基本类型，六种自负数字类型（四个整形、两个浮点型），一种字符类型和一种布尔型。

- byte：
  - byte类型是8位、有符号、以二进制补码表示的整数；
  - 最小值是-128
  - 最大值是127
  - 默认值是0
  - byte类型用在大型数组汇总节约空间，主要替代整数，因为byte变量占用的空间只有int类型的四分之一；
- short：
  - short数据类型是16位，有符号的二进制补码表示的整数；
  - 最小值是-32768；
  - 最大值是32767；
  - short数据类型也可以像byte那样节省空间，一个short变量是int变量所占空间的二分之一；
  - 默认值是0；
- int：
  - int数据类型是32位，有符号的以二进制补码表示的整数；
  - 最小值是-2,147,483,648；
  - 最大值是2,147,483,647；
  - 一般整型变量默认为int类型；
  - 默认值是0；
- long：
  - long数据类型是64位、有符号以二进制补码表示的整数；
  - 最小值：-9,223,372,036,854,775,808
  - 最大值是 9,223,372,036,854,775,807
  - long类型主要使用在需要比较大整数的系统上；
  - 默认值是0L；
- float：
  - float数据类型是单精度、32位、符合IEEE 754标准的浮点数；
  - float在存储大型浮点数组时可节省内存空间；
  - 默认值时0.0f
  - 浮点数不能用来表示精确的值，例如货币；
- double：
  - double数据类型是双精度、64位、符合IEEE 754标准的浮点数；
  - 浮点数的默认类型为double类型；
  - double类型同样不能表示精确的值；
  - 默认值是0.0d；
- boolean：
  - boolean数据类型表示一位的信息；
  - 只有两个取值：true和false；
  - 这种类型只作为一种标志来记录true/false的情况；
  - 默认值是false；
- char：
  - char类型是一个单一的16位Unicode字符；
  - 最小值是 **\u0000**（即为0）；
  - 最大值是 **\uffff**（即为65,535）；
  - char数据类型可以存储任何字符；

### 引用数据类型

- 引用类型非常类似于C/C++的指针，引用类型指向一个对象，指向对象的变量时引用变量。这些变量在声明时被指定为一个特定的类型，变量一旦声明后，类型就不能改变了。
- 对象、数组都是引用数据类型。
- 所有引用类型的默认都是null；
- 一个引用变量可以用来引用任何与之兼容的类型。

### java常量

- 常量在运行时是不能被修改的。
- 使用final关键字来修饰变量。

```java
final double PI = 3.1415927;
```

​		为了便于识别，常量通常用大写字母表示。

- 字面量可以赋值给人以内置类型的变量。例如

```java
char c = 68;
c.sout;//D
```

- Byte、int、long和short都可以用十进制、16进制、8进制表示
  - 在使用字面量时，前缀0表示8进制，0x表示16进制。

```java
int decimal = 100;
int octal = 0144;
int hexa = 0x64;
```

- 字符串常量是包含在两个引号之间的字符序列

```java
"Hello World"
"two\nlines"
"\"This is in quotes\""
```

字符串常量和字符常量都可以包含任何Unicode字符

```java
char a = '\u0001';
String a = "\u0001";
```

## 类型转换

整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转换为同一类型 ，之后再进行运算。转换从低级到高级。

```java
低  ------------------------------------>  高
byte,short,char->int->long->float->double
```

数据类型转换必须满足以下原则：

- 不能对boolean类型进行类型转换。
- 不能把对象类型转换成不相关类的对象。
- 在把大容量类型转换为小容量类型时必须使用强制类型转换。
- 转换过程中可能导致溢出或损失精度。如：

```java
int i = 128;
byte b = (byte)i;
System.out.println(b);//-128
```

byte最大值127，强制转换时溢出到下一个byte的最小值；

### 自动类型转换

​	必须满足转换前数据类型的位数要低于转换之后的数据类型。 如：char（16位）和int（32位）进行运算后变为int类型；

### 强制类型转换

1. 转换的数据类型必须是兼容的。
2. 格式：（type）value，type时强制类型转换后的数据类型。

### 隐含强制类型转换

1. 整数的默认类型是int。
2. 浮点型不存在这种情况，因为在定义float类型是必须在数字后面跟上F或f；

## Java变量类型

- 类变量：独立于方法之外的变量，用static修饰。
- 实例变量：独立于方法之外的变量，但没有static变量修饰。
- 局部变量：类的方法中的变量。

```java
public class Variable{
  static int allClicks = 0; //类变量
  String str = "hello world"; //实例变量
  public void method(){
    int i  = 0; //局部变量
  }
}
```

### java局部变量

- 局部变量声明在方法、构造方法或语句块中；
- 局部变量在方法、构造方法或语句块被执行时创建，执行完毕之后，局部变量会被销毁。
- 访问修饰符不能用于局部变量。
- 局部变量只在声明它的方法、构造方法或语句块中可见。
- 局部变量是在栈上分配的。
- 局部变量没有初始值，所以在被声明之后必须经过初始化才可使用。

### 实例变量（属性）

- 实例变量声明在一个类中，但不在方法和构造方法、语句块中。
- 当一个对象被实例化之后，每个实例变量的值就跟着确定。
- 实例变量在对象创建时跟着创建，在对象被销毁时跟着销毁。
- 实例变量的值应该至少被一个方法、构造方法或语句块引用（Getter And Setter），使得外部能够通过这些方式获取实例变量信息。
- 实例变量可以声明在使用前和使用后.
- 访问修饰符可以修饰实例变量。
- 实例变量对于类中的方法、构造方法和语句块可见，一般情况下把实例变量设为私有，通过使用访问修饰符可以使实例变量对子类可见。
- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量默认值是false，引用类型的默认值是null，变量的值可以在声明时指定也可以在构造方法中指定。
- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObjectReference.VariableName

### 类变量（静态变量）

- 类变量也称为静态变量，在类中以static关键字声明，但必须在方法之外。
- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
- 静态变量除了被声明为常量之外很少使用，静态变量是指声明为public/private，final和static类型的变量，静态变量初始化之后不可改变。
- 静态变量储存在静态存储区，经常被声明为常量，很少单独使用static声明变量。
- 静态便利那个在第一次访问时创建，在程序结束时销毁。
- 与实例变量具有相似的可见性，但为了对类的使用者可见，大多数静态变量声明为public类型。
- 默认值和实例变量相似，数值型变量的默认值是0，布尔型变量默认值是false，引用类型的默认值是null，变量的值可以在声明时指定也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
- 静态变量可以通过：ClassName.VariableName的方式访问。
- 类变量被声明为public static final类型时，类变量名称一般是用大写字母，若不是public和final类型，其命名方式和实例变量一样。

## Java修饰符

​	Java修饰符分为**访问修饰符**和**非访问修饰符**。

### 访问控制修饰符

​	可以使用访问控制修饰符来保护类、变量、方法和构造方法的访问，Java中有四种不同的访问权限。

- default（默认，什么都不写）：在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
- private：在同一类内可见。使用对象：变量、方法。**PS：**不能修饰外部类。
- public：对所有类可见。使用对象：类、接口、变量、方法。
- protect：

## String

String被声明为final，因此它不可被继承

java8中，String内部使用char数组存储数据。

```java
public final class String implements java.io.Serializable,Comparable<String>,CharSequence{
  //The value is used for charater storage
  private final byte[] value;
}
```

java9之后，String类的实现该用byte数组存储字符串，同时使用coder来标示使用了哪种编码。

```java
public final class String implements java.io.Serializable,Comparable<String>,CharSequence{
  private final byte[] value;
  
  private final byte coder;
}
```

value被声明为final，意味着value数组初始化之后就不能再饮用其他数组，并且String内部没有改变value数组的方法，因此可以保证String不可变。

### 不可变的好处

- 可以缓存hash值

因为String的hash值经常被使用，例如用String作为HashMap的key，不可变的特性使得hash值也不可改变，因此只需要一次计算。

- String Pool的需要

如果一个String对象已经被创建过了，那就会从String Pool中取得引用，若下次还创建一个一样的String，那么就会直接饮用之前存在的String。只有String是不可变的，才能使用String Pool。

- 安全性

String经常作为参数，String的不可变性保证参数不可变。

- 线程安全

String不可变性天生具备线程安全，可以在多个线程中安全的使用。

### String、StringBuffe和StringBuilder横向对比

1、可变性

- ​	String不可变
- Stringbuffer和StringBuilder可变

2、线程安全

- String不可变，因此是线程安全的
- StringBuilder不是线程安全的
- StringBuffer是线程安全的，内部使用synchronized进行同步



### 字符串常量池（String Pool）

​	概念：保存着所有字符串的字面量（literal strings），这些字面量在编译期就确定，不仅如此，还可以使用String的intern（）方法在运行过程中将字符串添加到String Pool中。

​	注意：当一个字符串调用intern（）方法时，如果String Pool中已经存在一个字符串和该字符串值相等（equals（）为true）时，那么就会返回String Pool中字符串的饮用；若不存在值相等的字符串，就在String Pool中添加一个新字符串，并返回这个新字符串的引用。

### 字符串的创建方式

​	1、String str = new String（“abc”）：new一个新的字符串，与其他对象的创建一样，每次new都是一个新的对象，并不在字符串常量池中，但传入的“abc”也是一个对象，若字符串常量池中有值为“abc”的字符串，则上述语句中的“abc”返回的是字符串常量池中已存在的对象，这种情况下，上述语句创建了一个对象。若字符串常量池中不存在值为“abc”的字符串，则上述语句中的“abc”在字符串常量池中创建了一个值为abc的字符串并返回新创建abc的引用，这种情况下上述语句创建了两个对象。

​	2、String str = “abc”：首先查找字符串常量池中有没有值一样的字符串存在，若存在，则返回一样值的字符串的引用，若不存在，则在字符串常量池中创建一个新的字符串，并返回新创建的字符串的引用。

​	**注意：**String的intern（）方法，在字符串常量池中若不存在与调用该方法字符串的值相同的字符串，则该方法会在字符串常量池中创建新字符串并返回新建字符串的引用，若存在则直接返回引用。



## 运算

​	1、创建的对象相当于指针，调用方法是传入对象是直接将地址值传给形参，形参也是一个指针，驱动程序的对象和被调用的方法中的形参互不干扰。

​	2、如果调用方法改变对象的字段值，就会改变该对象的值，因为改变的是同一个地址指向的内容。

​	3、java不能隐式向下转型，因为这会使得精度降低。

​		3.1、1.1字面量属于double类型，不能直接将1.1直接复制给float变量，因为是向下转型(double容量大于float)。

![image-20200912221234760](/Users/yangxiansheng/笔记/images/image-20200912221234760.png)

​		3.2、1.1f字面量才是float类型。

```java
float f = 1.1f;
```

4、



## IO模型详解

### 何为I/O

​	即输入/输出。I/o描述了计算机系统与外部设备之间通信的过程。

​	为了保证操作系统的稳定性和安全性，一个进程的地址空间被划分为用户空间（User space）和内核空间（Kernel space）。

​	平时运行的应用程序都是在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存股那里等等。即IO操作一定要依赖内核空间的能力。

​	并且用户空间的程序不能直接访问内核空间，当要执行IO操作时，必须发起**系统调用**请求操作系统完成操作。

​	当应用程序发起IO调用之后，会经历两个步骤：

1. 内核等待IO设备准备好数据。
2. 内核将数据拷贝至用户空间。

#### 常见的IO模型

​	UNIN系统下，IO模型一共有5种，**同步阻塞IO、同步非阻塞IO、IO多路复用、信号驱动IO和异步IO**。

### Java种3种常见IO模型

#### BIO（Blocking I/O）

> BIO属于同步阻塞IO模型

同步阻塞IO模型中，应用程序发起read调用后，会一直阻塞，直到内核把数据拷贝到用户空间。

![image-20220323081716151](images\image-20220323081716151.png)

​	在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

#### NIO（Non-blocking/New I/O）

​	Java中的NIO于1.4中引入，对应Java.nio包，提供了Channel、Selector、Buffer等抽象。它是支持面向缓冲、基于通道的IO操作方法。

> NIO可以看作是**IO多路复用模型**，先看同步非阻塞IO模型

#### 同步非阻塞IO模型

![image-20220323081211114](images\image-20220323081211114.png)

​	同步非阻塞IO模型中，应用程序会一直发起read调用，在等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到内核把数据拷贝到用户空间。

​	相比于同步阻塞IO模型，同步非阻塞IO确实有了很大改进，通过轮询操作，避免了一直阻塞。

​	但是也存在一个问题：应用程序不断进行IO系统调用轮询数据是否已经准备完毕的过程是十分消耗CPU资源的。

​	此时**IO多路复用模型**就上场了。

#### IO多路复用模型

![image-20220323082213088](images\image-20220323082213088.png)

IO多路服用模型中，线程首先发起select调用，询问内核数据是否准备完毕，等内核把数据准备好了，用户线程发起read调用。read调用的过程（数据从内核 ->用户）还是阻塞的。

> 目前支持IO多路复用的系统调用，有select、epoll等等。select系统调用几乎目前所有的操作系统都支持。
>
> - **select 调用** ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
> - **epoll 调用** ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

​	**IO多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗**。

​	Java中的NIO，有选择器（Selector）的概念，也可以被称为多路复用器，通过它，只需要一个线程就可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

![image-20220323165315005](images\image-20220323165315005.png)

#### AIO(Asynchronous I/O)

​	AIo，即NIO 2。Java7中引入了NIO的改进版，它是异步模型。

​	异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞，当后台处理完成，操作系统会通知相应线程进行后续的操作。

![image-20220323204031740](images\image-20220323204031740.png)

### 总结

![image-20220323204107900](images\image-20220323204107900.png)









 

