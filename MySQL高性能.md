# MySQL架构

## MySQL逻辑架构

![image-20221221154012458](\images\image-20221221154012458.png)

1. 第一层：连接处理、授权认证、安全等。
2. 第二层：大多数核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有内置函数（例如日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
3. 第三层：包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。和GNU/Linux下的各种文件系统一样，每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL，不同存储引擎之间也不会通信，只是简单响应上层服务器的请求。

### 连接管理与安全性

### 优化与执行

​	MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释（explain）优化过程的各个因素，使得用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置，使应用尽可能高效率的运行。、

​	优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或者某个具体操作的开销信息，以及表数据的统计信息等。
​	对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（Query  Cache），若能在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而直接返回查询缓存中的结果集。

## 并发控制

​	无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。

### 读写锁

​	在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排他锁，也叫读锁和写锁。

​	读锁是共享的，多个客户端可以同时读取同一个资源而互不干扰。写锁是排他的，**一个写锁会阻塞其他的写锁和读锁**，只有这样才能保证在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

### 锁粒度

​	一种提高共享资源并发性的方式就是让锁定对象更有选择性，尽量只锁定需要修改的部分数据而不是全部资源。更理想的方式是只锁定要修改的数据。锁定的资源越少则系统的并发程度就越高。

​	问题在于加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已解除、释放锁等，都会增加系统的性能开销。因此锁策略就是在数据安全和锁的开销之间寻求平衡。一般都是加行级锁并以各种复杂的方式来实现。

​	MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

#### 表锁（table lock）

​	表锁是MySQL中最基础的锁策略，并且是开销最小的策略。它会锁定整张表，在一个用户对这张表进行写操作（插入、更新和删除）时，会阻塞其他用户对该表的所有读写操作。



## 事务

- 原子性（atomicity）

​	一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中一部分操作。

- 一致性（consistency）

​	数据库总是从一个一致性状态到另一个一致性状态。在正在进行的事务中. 数据可能处于不一致的状态，如数据可能有部分被修改。然而，当事务成功完成时，数据必须再次回到已知的一致状态。通过事务对数据所做的修改不能损坏数据，或者说事务不能使数据存储处于不稳定的状态。

- 隔离性（isolation）

​	通常情况下，一个事务所做的修改在最终提交前，对其他事务是不可见的。

- 持久性（durability）

​	一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

### 隔离级别

​	在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统开销也越低。

- READ UNCOMMITED（读未提交）

  ​	在该级别中，事务的修改在未提交时，对其他事务也都是可见的，其他事务可以直接读取未提交的数据，也被称之为脏读。这个级别会导致很多问题，但从性能上来说，未提交读没有好很多，因此很少实际使用场景。

- READ COMMITED（读已提交）

  ​	大多数数据库系统的默认隔离级别（但MySQL不是）。一个事务只能看见已经提交的事务所做的修改。也称为不可重复读（nonrepeatable read），因为同一个事务中，同样的查询执行两次可能得到不一样的结果。

- REPEATABLE READ（可重复读）

  ​	该级别解决了脏读的问题，保证了在同一个事务中多次读取同样的记录的结果是一致的。但在理论上，该级别还无法解决另一个幻读（Phantom Read）问题。所谓幻读，是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行（Phantom Row）。InnoDb和XtraDb存储引擎通过使用多版本并发控制MVCC解决了幻读问题。

- SERIALIZABLE（可串行化）

  ​	是最高的隔离级别。它通过强制十五串行执行，避免了前面说的幻读问题。简单来说，该级别就是在读取的每一行数据都加上锁，所以可能导致大量的超时和锁争用问题。实际应用中很少采用该级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

![image-20230105144624626](\images\image-20230105144624626.png)

### 死锁

​	死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致的恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就有可能产生死锁。多个事务同时锁定 同一个资源时，也会产生死锁。

​	为了解决死锁，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误，快速响应用户。InnoDB处理死锁的方式是，将持有最少行级排他锁的事务进行回滚（相对简单的回滚算法）。还有一种解决死锁的方式：当查询时间达到锁等待超时的设定后放弃锁请求（通常不太好）。

​	锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：有些是因为真正的数据冲突（通常很难避免），有些则完全是因为存储引擎的实现方式导致的。

​	死锁发生后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统，这是无法避免的，在设计应用程序时必须考虑如何处理死锁，一般只需重新执行因死锁回滚的事务即可。

### 事务日志

​	事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到硬盘。事务日志采用的是追加的方式，因此写日志是磁盘上的顺序I/O，相对于修改数据本身持久化操作的随机I/O要快很多。

​	事务日志持久之后，内存中被修改的数据可以在后台慢慢刷回硬盘。目前大多数存储引擎都是这样实现的，称之为预写式日志（Write-Ahead Longging），修改数据需要写两次磁盘。

​	如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

### MySQL中的事务

#### 自动提交（AUTOCOMMIT）

​	MySQL默认采用自动提交模式，若开始时没有显式的开始一个事务，则每个查询都被当做一个事务来提交。在当前连接中，可以通过设置AUTOCOMMIT变量来启用或禁用自动提交模式：

![image-20230105155801096](\images\image-20230105155801096.png)

​	未开启自动提交时，所有的操作都在一个事务中，直到显式的执行commit提交或者ROLLBACK回滚，该事务结束，同时又开启一个新事务。

​	有些命令在执行之前会强制commit提交当前的活动事务，如：执行DDL（数据定义语言）时，如果是会导致大量数据改变的操作，像ALTER TABLE、LOCK TABLE等。

#### 隐式锁定和显式锁定

​	InnoDB采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行commit或者TOLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。

​	MySQL也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关，并不能代替事务处理。

![image-20230227084828046](\images\image-20230227084828046.png)



## 多版本并发控制（MVCC）

​	MVCC可以看成是行级锁的一个变种，但大多数情况下读操作没有加锁，写操作只锁定必要的行。

​	通过保存数据在某个时间点的快照来实现的，不同时间开始的事务在同一时刻看同一张表的数据可能是不一样的。

​	InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。一个保存了行的创建版本号，一个保存行的过期版本号（系统版本号），每个事务开始之前系统版本号会自增，事务开始时刻的版本号作为事务版本号，用来和查询到的数据进行比较：

> 在REPEATABLE READ级别下，每个操作如下所示：
>
> SELECT 
>
> 1. InnoDB会根据以下两个条件来检查每行记录：
>    1. InnoDB只查找系统版本号小于等于当前事务版本号的数据行，可以确保查到的数据是事务开始前或当前事务插入的。
>    2. 行的删除版本要么未定义，要么大于当前事务版本号，可以确保事务读取到的行在事务开始之前没被删除。
>
> INSERT
>
> ​	InnoDB为新插入的每一行保存当前系统版本号作为创建版本号。
>
> DELETE
>
> ​	InnoDB为删除的每一行保存当前系统版本号作为行删除标识
>
> UPDATE
>
> ​	InnoDB插入一条新数据，保存当前系统版本号为创建版本号，同时保存当前版本号到原来的行作为行删除标识。

​	保存这两个版本号，使得大多数读操作都可以不加锁，读操作简单且性能很好，保证只会读到符合标准的行。不足之处就是每行记录需要额外的存储空间，需要做更多的行检查工作以及一下额外的维护工作。

​	MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作，其他两个级别不兼容MVCC，因为READ UNCOMMITTED总是读取到最新的行，而不是符合当前事务版本的行，而SERIALIZABLE则对所有读取的行都加锁。

## MySQL中的存储引擎

### InnoDB存储引擎概览

1. 是MySQL的默认事务型引擎，它被设计来处理大量短期事务，短期事务大部分是会正常提交的，很少会回滚。
2. 数据存储在表空间（tablespace）中，是由InnoDB管理的一个黑盒子，由一系列数据文件组成。
3. 采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁（没太理解）（next-key locking）策略防止幻读的出现。间隙锁不仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
4. 表是基于聚簇索引建立的，对主键查询有很高的性能，不过二级索引必须包含主键列，所以如果主键列很大的话，其他索引也会很大，因此主键应当近可能的小。

### MyISAM存储引擎

----后续补充



### 转换表的引擎

1. 最简单的一个方法是ALTER TABLE语句：ALTER TABLE mytable ENGINE = InnoDB;

> 上述语法可以用于任何引擎，但需要执行很长时间，MySQL会按行把数据从原表复制到新表，期间可能消耗系统所有的IO能力，同时原表会加上读锁。

2. 导出与导入

> 使用mysqldump等工具将数据导出到文件，并修改文件中的建表语句的引擎选项和表名（不能存在相同的表名）

3. 创建与查询

> 综合了上述两种方法的优点，不需要导出整个表的数据，而是先创建一个新表，然后通过INSERT ---SELECT语句将数据从旧表导入到新表，如：
>
> create table innodb_table like myisam_table;
>
> alter table innodb_table ENGINE = InnoDB;
>
> INSERT INTO innodb_table SELECT * from myisam_table;
>
> 如果数据量过大，可以分批处理数据（主键分批）避免大事务产生过多的undo。如：
>
> START TRANSACTION；
>
> INSERT INTO innodb_table SELECT * from myisam_table where id BETWEEN x and y ;
>
> COMMIT;
>
> 完成上述操作后，新表是旧表的全量复制，如有需要可以在复制时加上写锁，保证新表和旧表数据一致。
>
> Percona Toolkit提供了一个pt-online-schema-change的工具，可以较为简单的执行上述过程，避免手工迁移出错。

# 服务器性能剖析

## 剖析MySQL查询

### 慢查询日志

​	MySQL会捕获超过设定执行时间（long_query_time，支持微妙级）的查询，慢查询日志是开销最低，精度最高的测量查询时间的工具，不过长期开启需要消耗大量的磁盘空间。



