# MySQL高性能

## MySQL逻辑架构

![image-20221221154012458](\images\image-20221221154012458.png)

1. 第一层：连接处理、授权认证、安全等。
2. 第二层：大多数核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有内置函数（例如日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
3. 第三层：包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。和GNU/Linux下的各种文件系统一样，每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL，不同存储引擎之间也不会通信，只是简单响应上层服务器的请求。

### 连接管理与安全性

### 优化与执行

​	MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释（explain）优化过程的各个因素，使得用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置，使应用尽可能高效率的运行。、

​	优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或者某个具体操作的开销信息，以及表数据的统计信息等。
​	对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（Query  Cache），若能在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而直接返回查询缓存中的结果集。

## 并发控制

​	无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。

### 读写锁

​	在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排他锁，也叫读锁和写锁。

​	读锁是共享的，多个客户端可以同时读取同一个资源而互不干扰。写锁是排他的，**一个写锁会阻塞其他的写锁和读锁**，只有这样才能保证在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

### 锁粒度

​	一种提高共享资源并发性的方式就是让锁定对象更有选择性，尽量只锁定需要修改的部分数据而不是全部资源。更理想的方式是只锁定要修改的数据。锁定的资源越少则系统的并发程度就越高。

​	问题在于加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已解除、释放锁等，都会增加系统的性能开销。因此锁策略就是在数据安全和锁的开销之间寻求平衡。一般都是加行级锁并以各种复杂的方式来实现。

​	MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

### 表锁（table lock）

​	表锁是MySQL中最基础的锁策略，并且是开销最小的策略。它会锁定整张表，在一个用户对这张表进行写操作（插入、更新和删除）时，会阻塞其他用户对该表的所有读写操作。



## 事务

- 原子性（atomicity）

​	一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中一部分操作。

- 一致性（consistency）

​	数据库总是从一个一致性状态到另一个一致性状态。在正在进行的事务中. 数据可能处于不一致的状态，如数据可能有部分被修改。然而，当事务成功完成时，数据必须再次回到已知的一致状态。通过事务对数据所做的修改不能损坏数据，或者说事务不能使数据存储处于不稳定的状态。

- 隔离性（isolation）

​	通常情况下，一个事务所做的修改在最终提交前，对其他事务是不可见的。

- 持久性（durability）

​	一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

### 隔离级别

​	在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统开销也越低。

- READ UNCOMMITED（未提交读）

  ​	在该级别中，事务的修改在未提交时，对其他事务也都是可见的，其他事务可以直接读取未提交的数据，也被称之为脏读。这个级别会导致很多问题，但从性能上来说，未提交读没有好很多，因此很少实际使用场景。

- READ COMMITED（提交读）

  ​	大多数数据库系统的默认隔离级别（但MySQL不是）。一个事务只能看见已经提交的事务所做的修改。也称为不可重复读（nonrepeatable read），因为同一个事务中，同样的查询执行两次可能得到不一样的结果。

- REPEATABLE READ（可重复读）

  ​	该级别解决了脏读的问题，保证了在同一个事务中多次读取同样的记录的结果是一致的。但在理论上，该级别还无法解决另一个幻读（Phantom Read）问题。所谓幻读，是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行（Phantom Row）。InnoDb和XtraDb存储引擎通过使用多版本并发控制MVCC解决了幻读问题。

- SERIALIZABLE（可串行化）

  ​	是最高的隔离级别。它通过强制十五串行执行，避免了前面说的幻读问题。简单来说，该级别就是在读取的每一行数据都加上锁，所以可能导致大量的超时和锁争用问题。实际应用中很少采用该级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

![image-20230105144624626](\images\image-20230105144624626.png)

### 死锁

​	死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致的恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就有可能产生死锁。多个事务同时锁定 同一个资源时，也会产生死锁。

​	为了解决死锁，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误，快速响应用户。InnoDB处理死锁的方式是，将持有最少行级排他锁的事务进行回滚（相对简单的回滚算法）。还有一种解决死锁的方式：当查询时间达到锁等待超时的设定后放弃锁请求（通常不太好）。

​	锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：有些是因为真正的数据冲突（通常很难避免），有些则完全是因为存储引擎的实现方式导致的。

​	死锁发生后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统，这是无法避免的，在设计应用程序时必须考虑如何处理死锁，一般只需重新执行因死锁回滚的事务即可。

### 事务日志

​	事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到硬盘。事务日志采用的是追加的方式，因此写日志是磁盘上的顺序I/O，相对于修改数据本身持久化操作的随机I/O要快很多。

​	事务日志持久之后，内存中被修改的数据可以在后台慢慢刷回硬盘。目前大多数存储引擎都是这样实现的，称之为预写式日志（Write-Ahead Longging），修改数据需要写两次磁盘。

​	如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

### MySQL中的事务

#### 自动提交（AUTOCOMMIT）

​	MySQL默认采用自动提交模式，若开始时没有显式的开始一个事务，则每个查询都被当做一个事务来提交。在当前连接中，可以通过设置AUTOCOMMIT变量来启用或禁用自动提交模式：

![image-20230105155801096](\images\image-20230105155801096.png)









